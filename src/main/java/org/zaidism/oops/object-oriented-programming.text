‚úÖ Object-Oriented Programming (OOP) Concepts with Real-World Examples

 1. Encapsulation

> Definition: Encapsulation is about controlling access to an object's internal state. It hides data using private fields and provides access through public getter and setter methods.

> Real-World Example: In an e-commerce application, a `Product` class might encapsulate inventory logic so that product quantity can only be changed in controlled ways.


public class Product {
    private String name;
    private int quantity;

    public Product(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    public int getQuantity() {
        return quantity;
    }

    public void reduceQuantity(int amount) {
        if (amount <= quantity) {
            quantity -= amount;
        } else {
            throw new IllegalArgumentException("Insufficient stock!");
        }
    }

    public String getName() {
        return name;
    }
}



 2. Inheritance (https://www.scaler.com/topics/java/inheritance-in-java/)

> Definition: Inheritance allows a class to reuse the properties and behavior of another class. This promotes code reusability.

> Real-World Example: A `BaseEntity` class that contains common fields for all entities like `id`, `createdAt`, and `updatedAt`.


public class BaseEntity {
    private Long id;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Getters and setters
}

public class User extends BaseEntity {
    private String name;
    private String email;

    // Getters and setters
}


 3. Abstraction

> Definition: Abstraction hides complex internal logic and exposes only the necessary functionality to the user.

> Real-World Example: You can use utility methods like `Math.max()` or collection methods like `Set.remove()` without knowing how they are implemented internally.


public class AbstractionExample {
    public static void main(String[] args) {
        int max = Math.max(10, 20); // Abstracts the comparison logic
        Set<String> set = new HashSet<>();
        set.add("apple");
        set.remove("apple"); // You don‚Äôt know if it uses hashing or not
    }
}


 4. Polymorphism

> Definition: Polymorphism allows one interface to have multiple implementations, and the behavior can vary based on the actual object at runtime.

> Real-World Example: A `NotificationService` interface with different implementations for Email, SMS, and Push notifications.


public interface NotificationService {
    void sendNotification(String message);
}

public class EmailNotificationService implements NotificationService {
    public void sendNotification(String message) {
        System.out.println("Email: " + message);
    }
}

public class SMSNotificationService implements NotificationService {
    public void sendNotification(String message) {
        System.out.println("SMS: " + message);
    }
}

@RestController
@RequestMapping("/api/notifications")
public class NotificationController {
    private final List<NotificationService> notificationServices;

    public NotificationController(List<NotificationService> notificationServices) {
        this.notificationServices = notificationServices;
    }

    @GetMapping("/send")
    public String sendNotification() {
        for (NotificationService service : notificationServices) {
            service.sendNotification("heiiii"); // polymorphic call
        }
        return "Notifications sent to all channels!";
    }
}



 ‚úÖ Summary

| Concept       | Purpose                               | Real-World Analogy                                  |
| ------------- | ------------------------------------- | --------------------------------------------------- |
| Encapsulation | Protect internal state                | Secure access to product inventory                  |
| Inheritance   | Reuse code                            | Common entity fields shared across multiple classes |
| Abstraction   | Hide complexity, expose functionality | Using `Set.remove()` or `Math.max()`                |
| Polymorphism  | One interface, many implementations   | Email/SMS/Push services under `NotificationService` |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- Single .java file can always have maximum only one public class, and name of public class will be always same as file name.
- We can have multiple class in the .java file which are not public
- Class is blueprint of object which has some properties (variables) and behaviour (methods). Object is an instance of a class.
- (Example: Human is template/blueprint/class, Child, Boy, Men, Women can be it's Objects. Their behaviour could be walk, eat etc...)
- We can access properties and behaviour of a class using objects
- If you have two constructor one is parameterized constructor and one is default constructor in your class you can call default constructor in your parameterized constructor using this().
- Example:
    static int count;

    public Person() {
        count++;
        System.out.println("creating an object");
    }

    public Person(int newAge, String newName) {
        this(); // example
        this.name = newName;
        this.age = newAge;
    }

- During inheritance super class is used to call parent class constructor
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Real-life Illustration of Polymorphism in Java: A person at the same time can have different characteristics. Like a man at the same time is a father, a husband,
and an employee. So the same person possesses different behaviors in different situations. This is called polymorphism.

Types of Java Polymorphism
    1. Compile-time Polymorphism (Method Overloading)
    2. Runtime Polymorphism also know as Dynamic Method Dispatch (Method Overriding)


1. Compile-time/Static Polymorphism (Method Overloading):

If a class has multiple methods having same name but different in parameters, it is known as Method Overloading.

Refer code: MethodOverloadingDemo
Scenario 1 demonstrates overloading with different parameter types.
Scenario 2 shows overloading with a different number of parameters.
Scenario 3 illustrates overloading with a different order of parameters.
Scenario 4 overloading with different return types compilation error.
Scenario 5 demonstrates overloading static methods.

- Overloaded methods must have the same name.
- Overloaded methods must have different parameter lists (number, order, or types of parameters).
- An attempt to overload the main method shows that only the standard main(String[] args) method is recognized as the entry point for the program.
- Multiple main methods can be declared and overloaded, but only the standard main(String[] args) is recognized as the entry point for the program.
- Jvm checks for only main method which has signature like this (String[] args) an method name as main so only that method can be considered as entry
  point of program not the overloaded methods

- We can overload static methods but we need to use class name to call static methods


2. Runtime Polymorphism/Dynamic Method Dispatch (Method Overriding):

It is a process in which a function call to the overridden method is resolved at Runtime. This type of polymorphism is achieved by Method Overriding.
If a method name in base class is same it's child classes but with same arguments types, order of arguments & number of arguments then it is called method
overloading.

Rules for overriding a method in Java
- There must be inheritance between classes.
- The method between the classes must be the same(name of the class, number, and type of arguments must be the same).
- Static methods can't be overridden

Refer code: MethodOverridingDemo.java & StaticMethodOverrideDemo.java
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Access Modifiers in java:
- Private: Accessible only within the class.
- Public: Accessible from anywhere in the Java program.
- Protected: Classes in same package + subclasses in other packages
- Default (Package-private): Accessible only within the same package.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. When should you use an abstract class, and when should you use an interface? // abstract classes can have constructors


‚úÖ When to Use an Abstract Class vs. an Interface in Java

 üìå 1. Abstract Class

> Use an abstract class when:

 You want to provide a common base with some shared implementation.
 Classes share state (fields/variables) and behavior.
 You want to evolve the class hierarchy without breaking existing code (because you can add new methods with default implementations).
 You expect that classes are closely related or logically belong to the same family.

 üìå 2. Interface

> Use an interface when:

 You want to define a contract (what needs to be done) without enforcing how.
 You need to support multiple inheritance (a class can implement many interfaces).
 You expect that classes implementing the interface may come from unrelated hierarchies.
 You are building for loose coupling and flexibility (e.g., plugins, strategies, services).



 ‚úÖ RealWorld Examples

 üî∂ Abstract Class Example: BaseEntity in a Spring Boot App

public abstract class BaseEntity {
    private Long id;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public void updateTimestamps() {
        updatedAt = LocalDateTime.now();
    }

    // Shared logic across entities
}


Used when multiple entities (e.g. User, Order, Product) share state and behavior.


 üî∑ Interface Example: NotificationService


public interface NotificationService {
    void send(String message);
}

public class EmailNotification implements NotificationService {
    public void send(String message) {
        // send email
    }
}

public class SmsNotification implements NotificationService {
    public void send(String message) {
        // send SMS
    }
}

Used when multiple unrelated classes need to fulfill the same contract (send()), possibly via dependency injection (Spring).


 ‚úÖ Summary Table

| Feature                      | Abstract Class                          | Interface                                    |
|                              |                                         |                                              |
| Can have method bodies       | ‚úÖ Yes (with/without abstract methods)  | ‚úÖ Yes (default/static methods since Java 8) |
| Can have instance variables  | ‚úÖ Yes                                  | ‚ùå No (only constants)                       |
| Multiple inheritance support | ‚ùå No (only one abstract class allowed) | ‚úÖ Yes (can implement multiple interfaces)   |
| Constructor                  | ‚úÖ Yes                                  | ‚ùå No                                        |
| Suitable for                 | Shared code, base classes               | Contracts, loose coupling                     |
| Spring Use Case              | BaseEntity, AbstractController          | @Service, @Repository, RestController         |



 üß† InterviewReady Answer

> ‚ÄúI use an abstract class when I need to provide a common base with some shared code or fields ‚Äî for example, a BaseEntity in a Spring Boot app that all entities extend.
I use an interface when I want to define a contract that can be implemented by different and unrelated classes ‚Äî for example, a NotificationService implemented by Email, SMS, or Push. Interfaces are also ideal in Spring for dependency injection and loose coupling.‚Äù
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Follow up question on above question: what's the advantage of creating public abstract class BaseEntity because this can be achieved without making the class as non abstract as well

 ‚úÖ Why Make BaseEntity Abstract?

 ‚ú≥Ô∏è 1. Intentional Design

> Declaring BaseEntity as abstract communicates intent clearly:

 ‚ÄúThis class is not meant to be instantiated on its own.‚Äù
 It‚Äôs a base template, not a concrete domain entity.

public abstract class BaseEntity {
    private Long id;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Shared logic...
}


Even if technically it could be a concrete class, abstract makes the purpose explicit.

 ‚ú≥Ô∏è 2. Prevents Accidental Instantiation

If it‚Äôs not abstract, someone could do:

BaseEntity entity = new BaseEntity(); // This doesn't make sense logically!

But BaseEntity is usually meant to be extended by entities like User, Product, etc. Making it abstract avoids incorrect usage.


 ‚ú≥Ô∏è 3. Forcing Subclass Responsibility

You can define abstract methods in BaseEntity if needed:

public abstract String getEntityType();

This ensures that all subclasses must implement specific behavior ‚Äî helping enforce design consistency across the domain model.


 ‚ú≥Ô∏è 4. Improved Readability and Maintenance

Developers reading the code immediately understand:

 This is a base class
 It‚Äôs not meant to be persisted or used directly
 It‚Äôs used to enforce common behavior across entities

This improves codebase maintainability and avoids misuse.


 üîÅ What If We Don‚Äôt Make It Abstract?

Yes, technically it works:


public class BaseEntity {
    private Long id;
    private LocalDateTime createdAt;
}


But then:

 It looks like a normal instantiable class
 Someone might treat it as a fullfledged model (e.g., try to persist BaseEntity)
 It doesn‚Äôt communicate its design intent clearly



 ‚úÖ Summary

| Point                           | abstract BaseEntity        | concrete BaseEntity                          |
|                                 |                            |                                              |
| Instantiation                   | ‚ùå Not allowed             | ‚úÖ Allowed (but often meaningless)           |
| Communicates baseonly intent    | ‚úÖ Yes, clearly            | ‚ùå No, ambiguous                             |
| Allows abstract methods         | ‚úÖ Yes                     | ‚ùå No                                        |
| Prevents accidental persistence | ‚úÖ Helps prevent it        | ‚ùå Could happen                              |
| Best for                        | Template/shared structure | Utility class or shared model (rarely used) |

 üß† Interview Answer

> ‚ÄúMaking BaseEntity abstract helps prevent accidental instantiation and clarifies its role as a base class.
It improves readability and makes the design intent explicit. While technically it can be nonabstract, marking it abstract makes it clear that it‚Äôs just a template for concrete entities like User, Order, or Product.‚Äù
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

| Feature                 | Composition                                  | Aggregation                                    |
| ----------------------- | ------------------------------------------------ | -------------------------------------------------- |
| Definition          | Strong "has-a" relationship (tight coupling) | Weak "has-a" relationship (loose coupling)     |
| Ownership           | Parent owns child object                     | Parent uses child object                       |
| Example             | `House has-a Room` (room dies with house)        | `Team has-a Player` (player can join another team) |
| Java Implementation | Direct instantiation inside the class            | Passed via constructor or setter (reference only)  |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------